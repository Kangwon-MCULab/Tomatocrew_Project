"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path_1 = require("path");
const globby = require("globby");
const krjson_1 = require("krjson");
function callbackToPromise(call) {
    const savedStack = new Error('').stack || '';
    return new Promise((resolve, reject) => {
        call((err, data) => {
            if (err) {
                var stackline = savedStack.indexOf('\n');
                stackline = savedStack.indexOf('\n', stackline + 1);
                if (stackline !== -1) {
                    err.stack = err.message + savedStack.substr(stackline);
                }
                reject(err);
            }
            else
                resolve(data);
        });
    });
}
const win32 = os.platform() === 'win32';
function win32_drivePrefix(path) {
    if (path.charAt(1) === ':')
        return path.substr(0, 2);
    if (path.startsWith('\\\\')) {
        const driveidx = path.indexOf('\\', 2);
        if (driveidx === -1)
            return path;
        return path.substr(0, driveidx);
    }
    return '';
}
function win32_join(...path) {
    var i = path.length;
    while (i--) {
        const p = path[i];
        if (p.charAt(1) === ':') {
            return mypath.normalize(path.slice(i).join(path_1.sep));
        }
        if (p.startsWith('\\\\')) {
            return mypath.normalize(path.slice(i).join(path_1.sep));
        }
        if (p.startsWith('\\') || p.startsWith('/')) {
            var j = i;
            while (j--) {
                const p2 = path[j];
                const driveprefix = win32_drivePrefix(p2);
                if (driveprefix) {
                    return mypath.normalize(driveprefix + path.slice(i).join('\\'));
                }
            }
            return mypath.normalize(path.slice(i).join(path_1.sep));
        }
    }
    return mypath.normalize(path.join(path_1.sep));
}
function unix_join(...path) {
    var i = path.length;
    while (i--) {
        const p = path[i];
        if (p.startsWith('\\') || p.startsWith('/')) {
            return mypath.normalize(path.slice(i).join(path_1.sep));
        }
    }
    return mypath.normalize(path.join(path_1.sep));
}
function win32_resolve(path) {
    if (path.charAt(1) === ':') {
        return mypath.normalize(path);
    }
    else if (path.startsWith('/') || path.startsWith('\\')) {
        return mypath.join(process.cwd(), path);
    }
    else {
        return mypath.normalize(path);
    }
}
function unix_resolve(path) {
    if (path.startsWith('/') || path.startsWith('\\')) {
        return mypath.join(process.cwd(), path);
    }
    else {
        return mypath.normalize(path);
    }
}
const mypath = {
    dirname(path) {
        const idx = path.lastIndexOf(path_1.sep);
        if (idx === -1)
            return '';
        return path.substr(0, idx);
    },
    normalize(path) {
        const npath = [];
        const pathes = path.split(/[\\\/]/g);
        for (const p of pathes) {
            switch (p) {
                case '..':
                    if (npath.length === 0 || npath[npath.length - 1] === '..') {
                        npath.push('..');
                    }
                    else {
                        npath.pop();
                    }
                    break;
                case '':
                case '.':
                    break;
                default:
                    npath.push(p);
                    break;
            }
        }
        const res = npath.join(path_1.sep);
        if (path.startsWith('\\\\'))
            return '\\\\' + res;
        if (path.startsWith('\\') || path.startsWith('/'))
            return path_1.sep + res;
        return res;
    },
    resolve: win32 ? win32_resolve : unix_resolve,
    join: win32 ? win32_join : unix_join,
};
function mkdirParent(dirPath, callback) {
    return fs.mkdir(dirPath, error => {
        if (error) {
            switch (error.code) {
                case 'EEXIST':
                    callback();
                    return;
                case 'ENOENT':
                    return mkdirParent(mypath.dirname(dirPath), () => fs.mkdir(dirPath, callback));
            }
        }
        callback && callback(error);
    });
}
class File {
    constructor(fsPath) {
        this.fsPath = mypath.resolve(fsPath);
    }
    toString() {
        throw Error('Blocked to find bug');
    }
    in(parent) {
        return this.fsPath.startsWith(parent.fsPath + path_1.sep);
    }
    initJson(defaultValue) {
        return this.json().then((data) => {
            var changed = false;
            for (var p in defaultValue) {
                if (p in data)
                    continue;
                data[p] = defaultValue[p];
                changed = true;
            }
            if (!changed)
                return data;
            return this.create(JSON.stringify(data, null, 4))
                .then(() => data);
        })
            .catch(() => {
            return this.create(JSON.stringify(defaultValue, null, 4))
                .then(() => Object.create(defaultValue));
        });
    }
    basename() {
        const idx = this.fsPath.lastIndexOf(path_1.sep);
        return this.fsPath.substr(idx + 1);
    }
    filenameWithoutExt() {
        const name = this.basename();
        const extidx = name.indexOf('.');
        if (extidx === -1)
            return name;
        return name.substr(0, extidx);
    }
    /**
     * ext with dot
     */
    ext() {
        const name = this.basename();
        const idx = name.lastIndexOf('.');
        if (idx === -1)
            return '';
        return name.substr(idx);
    }
    reext(newext) {
        const pathidx = this.fsPath.lastIndexOf(path_1.sep);
        const extidx = this.fsPath.indexOf('.', pathidx + 1);
        if (extidx === -1)
            new File(this.fsPath + '.' + newext);
        return new File(this.fsPath.substr(0, extidx + 1) + newext);
    }
    children() {
        return __awaiter(this, void 0, void 0, function* () {
            const files = yield callbackToPromise((callback) => fs.readdir(this.fsPath, callback));
            return files.map(filename => this.child(filename));
        });
    }
    sibling(filename) {
        return new File(mypath.join(mypath.dirname(this.fsPath), filename));
    }
    /**
     * Find not duplicated file name with index
     */
    findEmptyIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.exists()))
                return this;
            const basename = this.basename();
            const idx = basename.lastIndexOf('.');
            var filename;
            var ext;
            if (idx === -1) {
                filename = this.fsPath + '.';
                ext = '';
            }
            else {
                const extidx = this.fsPath.length - basename.length + idx;
                filename = this.fsPath.substr(0, extidx) + '.';
                ext = this.fsPath.substr(extidx);
            }
            var index = 2;
            for (;;) {
                const nfile = new File(filename + index + ext);
                if (!(yield nfile.exists()))
                    return nfile;
                index++;
            }
        });
    }
    child(...filename) {
        return new File(mypath.join(this.fsPath, ...filename));
    }
    parent() {
        return new File(mypath.dirname(this.fsPath));
    }
    relativeFrom(parent) {
        const parentPath = parent.fsPath;
        const fsPath = this.fsPath;
        if (fsPath.startsWith(parentPath)) {
            if (parentPath.length === fsPath.length)
                return '.';
            const rpath = fsPath.substr(parentPath.length).replace(/\\/g, '/');
            if (rpath.startsWith('/')) {
                return rpath.substr(1);
            }
        }
        return undefined;
    }
    glob(pattern) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = yield globby(this.child(pattern).fsPath);
            return files.map(path => new File(path));
        });
    }
    stat() {
        return callbackToPromise((callback) => fs.stat(this.fsPath, callback));
    }
    mtime() {
        return this.stat().then(stat => +stat.mtime).catch(e => {
            if (e.code === 'ENOENT')
                return -1;
            throw e;
        });
    }
    mkdir() {
        return new Promise((resolve, reject) => {
            fs.mkdir(this.fsPath, (err) => {
                if (err) {
                    switch (err.code) {
                        case 'EEXIST':
                            resolve();
                            return;
                        default:
                            reject(err);
                            return;
                    }
                }
                else
                    resolve();
            });
        });
    }
    mkdirp() {
        return callbackToPromise(callback => mkdirParent(this.fsPath, callback));
    }
    lstat() {
        return callbackToPromise((callback) => fs.lstat(this.fsPath, callback));
    }
    open() {
        return callbackToPromise((callback) => fs.readFile(this.fsPath, "utf-8", callback));
    }
    createWriteStream() {
        return fs.createWriteStream(this.fsPath);
    }
    exists() {
        return new Promise((resolve) => fs.exists(this.fsPath, resolve));
    }
    json() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.open();
            try {
                return krjson_1.parseJson(data);
            }
            catch (err) {
                if (err instanceof Error)
                    err.file = this;
                throw err;
            }
        });
    }
    create(data) {
        return this.parent().mkdirp()
            .then(() => callbackToPromise((callback) => fs.writeFile(this.fsPath, data, "utf-8", callback)));
    }
    createSync(data) {
        return fs.writeFileSync(this.fsPath, data, "utf-8");
    }
    unlink() {
        return callbackToPromise((callback) => fs.unlink(this.fsPath, callback));
    }
    quietUnlink() {
        return new Promise(resolve => fs.unlink(this.fsPath, () => resolve()));
    }
    isDirectory() {
        return this.stat().then(stat => stat.isDirectory());
    }
}
exports.File = File;
//# sourceMappingURL=index.js.map